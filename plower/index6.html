<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>RAGベース NotebookLM風ローカルアプリ「plower」</title>
    <script src='https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js'></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            line-height: 1.6;
        }

        /* ファイル内容表示エリア */
        #fileContent {
            white-space: pre-wrap;
            background: #eef;
            padding: 10px;
            margin-top: 10px;
            border: 1px solid #ccc;
            min-height: 50px;
            max-height: 250px;
            overflow-y: auto;
        }
        
        /* 貼り付けエリア */
        #pasteArea {
            height: 50px;
        }
        
        /* 入力系 */
        textarea {
            width: 100%;
            height: 100px;
            margin-top: 5px;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ccc;
        }

        #userInput {
            margin-bottom: 5px;
        }

        label {
            display: block;
            margin-top: 15px;
            font-weight: bold;
        }

        select {
            padding: 8px;
            border: 1px solid #ccc;
            margin-right: 10px;
        }

        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            margin-top: 10px;
        }

        button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }

        /* チャットログ */
        #chatLog {
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        #chatLog p {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #chatLog strong {
            color: #333;
            font-weight: bold;
        }
        
        /* 貼り付けた画像スタイル */
        #fileContent img {
            max-width: 100%;
            height: auto;
            border: 2px solid #555;
            margin-top: 5px;
            display: block;
        }
        
        /* OCRステータス表示 */
        .ocr-status {
            font-weight: bold;
            padding: 5px 0;
            border-bottom: 1px dashed #ccc;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <h1>RAGベース NotebookLM風アプリ「plower」</h1>

    <label for="fileInput">RAGソース文書 (Textファイル):</label>
    <input type="file" id="fileInput" accept=".txt" multiple>
    <div id="fileContent">【ここに読み込まれた文書の内容や貼り付けた画像が表示されます】</div>

    <label for="pasteArea">一時的なRAGコンテキストとしてテキストまたは画像を貼り付け:</label>
    <textarea id="pasteArea" placeholder="ここにテキストを貼り付けてください。Ctrl+Vで画像を貼り付けるとOCR処理が開始されます。"></textarea>

    <label for="userInput">質問を入力:</label>
    <textarea id="userInput" placeholder="質問を入力してください..."></textarea>
    
    <label for="modelSelect">モデル選択:</label>
    <select id="modelSelect">
        <option value="gemma:7b">Gemma 7B</option>
        <option value="gpt-oss:20b" selected>GPT-OSS 20B</option>
        <option value="gemma3:12b">Gemma 12B</option>
        <option value="gpt-oss:120b">GPT-OSS 120B</option>
    </select>
    
    <button id="sendButton">送信</button>
    
    <div id="chatLog"></div>

    <script>
        // ファイル入力で読み込まれた文書を格納
        let fileDocuments = [];
        // 貼り付け画像からOCR処理で生成された文書を格納（RAG対象）
        let ocrDocuments = []; 
        // 貼り付けエリアのテキスト文書を格納（RAG対象）
        let pasteTextDocument = null; 
        
        // Tesseract Workerを初期化（OCR処理用）
        let worker;

        // --- Tesseract.js OCR処理関数 ---
        async function runOcrOnImage(base64Image, statusElement) {
            if (!worker) {
                // 初回実行時のみWorkerを作成（日本語言語ファイルをロード）
                statusElement.textContent = 'OCRワーカーを初期化中... (初回のみ時間がかかります)';
                worker = await Tesseract.createWorker({
                    logger: m => {
                        if (m.status === 'recognizing text' && m.progress) {
                            statusElement.textContent = `OCR処理中: ${Math.round(m.progress * 100)}%`;
                        } else if (m.status) {
                            statusElement.textContent = `OCRステータス: ${m.status}`;
                        }
                    },
                });
                // 日本語と英語の言語ファイルをロード
                await worker.loadLanguage('jpn+eng');
                await worker.initialize('jpn+eng');
                statusElement.textContent = 'OCRワーカーの初期化完了。テキスト認識中...';
            }

            // OCR実行
            const { data: { text } } = await worker.recognize(base64Image);
            
            return text;
        }


        // --- ファイル入力のイベントリスナー ---
        document.getElementById('fileInput').addEventListener('change', function () {
            const files = this.files;
            fileDocuments = []; 
            let displayText = '';
            const fileContentDiv = document.getElementById('fileContent');
            
            // 既存の画像コンテンツとOCRステータスを一時的に取得
            const existingContent = Array.from(fileContentDiv.children);
            fileContentDiv.innerHTML = 'ファイルを読み込み中です...'; 
            
            // 既存の画像とOCRステータスを再挿入
            existingContent.forEach(el => {
                if (el.tagName === 'IMG' || el.classList.contains('ocr-status')) {
                    fileContentDiv.appendChild(el);
                }
            });

            const fileReads = Array.from(files).map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        fileDocuments.push({ name: file.name, content: e.target.result });
                        displayText += `【${file.name}】\n` + e.target.result.slice(0, 300) + '...\n\n';
                        resolve();
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            });

            Promise.all(fileReads)
                .then(() => {
                    // ファイル内容の表示を更新
                    fileContentDiv.insertAdjacentHTML('afterbegin', (displayText || 'ファイルが選択されていません。'));
                })
                .catch(error => {
                    fileContentDiv.insertAdjacentHTML('afterbegin', 'ファイルの読み込み中にエラーが発生しました。');
                    console.error("File reading error:", error);
                });
        });
        
        // --- 貼り付け画像処理のイベントリスナー (OCR連携ロジック) ---
        document.getElementById('pasteArea').addEventListener('paste', async function (e) {
            const items = e.clipboardData.items;
            let imageFound = false;
            
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.type.indexOf('image') !== -1) {
                    e.preventDefault(); 
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    imageFound = true;

                    // 既存のOCR関連要素をクリア
                    document.querySelectorAll('#fileContent img, #fileContent .ocr-status').forEach(el => el.remove());

                    // 処理中メッセージ表示要素
                    const processingMessage = document.createElement('p');
                    processingMessage.className = 'ocr-status';
                    processingMessage.textContent = '画像を貼り付けました。OCR処理を開始しています...';
                    processingMessage.style.color = 'orange';
                    document.getElementById('fileContent').prepend(processingMessage);

                    reader.onload = async function (event) {
                        const base64Image = event.target.result;
                        const imageName = `貼り付け画像_${Date.now()}`;
                        
                        // 画像をfileContentエリアに表示
                        const img = document.createElement('img');
                        img.src = base64Image;
                        img.alt = imageName;
                        document.getElementById('fileContent').prepend(img);
                        
                        try {
                            // 1. OCR処理を実行
                            const ocrText = await runOcrOnImage(base64Image, processingMessage);
                            
                            // 2. OCR結果をRAG文書に追加（既存のOCR結果をクリアして新しいものに置き換え）
                            ocrDocuments = [];
                            const fullOcrContent = `【OCR結果 - ${imageName}】\n${ocrText.trim()}`;
                            ocrDocuments.push({
                                name: imageName,
                                content: fullOcrContent
                            });
                            
                            // 3. ステータス更新
                            processingMessage.textContent = `OCR処理完了: ${imageName} のテキストがRAG対象に追加されました。抽出テキストの最初の50文字: ${ocrText.trim().slice(0, 50)}...`;
                            processingMessage.style.color = 'green';
                            
                        } catch (error) {
                            processingMessage.textContent = `OCR処理中にエラーが発生しました: ${error.message}`;
                            processingMessage.style.color = 'red';
                            console.error("OCR Error:", error);
                        } finally {
                            // pasteAreaのテキストをクリア
                            document.getElementById('pasteArea').value = '';
                        }
                    };
                    reader.readAsDataURL(blob);
                    break;
                }
            }
        });


        // --- 関連文書検索ロジック (キーワードマッチング) ---
        function findRelevantDocs(query, docs, topK = 3) {
            if (!docs || docs.length === 0) return [];
            
            const scores = docs.map(doc => {
                const content = (doc.content || '').toLowerCase();
                const terms = query.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").split(/\s+/).filter(t => t.length > 0);
                let score = 0;
                
                terms.forEach(term => {
                    const count = (content.match(new RegExp(term, 'g')) || []).length;
                    score += count;
                });
                return { ...doc, score };
            });
            
            return scores.sort((a, b) => b.score - a.score).slice(0, topK);
        }

        // --- モデル送信ロジック ---
        async function sendToModel() {
            const userInputElement = document.getElementById('userInput');
            const userInput = userInputElement.value.trim();
            const pasteAreaContent = document.getElementById('pasteArea').value.trim();
            const chatLog = document.getElementById('chatLog');
            const sendButton = document.getElementById('sendButton');
            const modelSelect = document.getElementById('modelSelect').value;

            if (!userInput) {
                alert("質問を入力してください。");
                return;
            }
            
            sendButton.disabled = true;
            sendButton.textContent = '送信中...';
            chatLog.innerHTML += `<p><strong>質問:</strong> ${userInput}</p>`;
            const responseParagraph = document.createElement('p');
            responseParagraph.innerHTML = '<strong>回答:</strong> ';
            chatLog.appendChild(responseParagraph);
            
            // 貼り付けエリアのテキスト内容を一時的なドキュメントとして追加（質問ごとに内容を更新）
            pasteTextDocument = pasteAreaContent ? { name: '貼付けテキスト', content: pasteAreaContent } : null;

            // RAGの対象となる全ドキュメントリストを作成: ファイル、OCR結果、貼り付けテキストの順
            let allDocuments = [...fileDocuments, ...ocrDocuments];
            if (pasteTextDocument) {
                allDocuments.push(pasteTextDocument);
            }

            // RAGコンテキストの生成
            const relevantDocs = findRelevantDocs(userInput, allDocuments);
            const context = relevantDocs.map(doc => `【${doc.name}】\n${doc.content}`).join('\n\n').slice(0, 5000);
            
            // プロンプトの生成
            const prompt = `あなたはRAGシステムとして機能します。提供された以下の文書に基づいて、ユーザーの質問に日本語で簡潔に答えてください。
            文書に関連情報がない場合は、「提供された文書に関連情報がないため回答できません。」と伝えてください。
            参照した文書名（【文書名】）を引用として回答の末尾に記載しても構いません。

--- 文書 ---
${context}
---

質問: ${userInput}`;

            // コンテキストサイズの設定: 20B/12B/120Bは8192、それ以外は4096
            const numCtx = (modelSelect.includes('20b') || modelSelect.includes('12b') || modelSelect.includes('120b')) ? 8192 : 4096;

            let result = '';
            try {
                const response = await fetch('http://localhost:11434/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: modelSelect, 
                        prompt: prompt,
                        stream: true,
                        options: {
                            temperature: 0.1, 
                            num_ctx: numCtx
                        }
                    })
                });

                if (!response.ok) throw new Error(`Ollamaサーバーエラー: ${response.status} ${response.statusText}. モデル: ${modelSelect} がロードできませんでした。`);

                if (!response.body) throw new Error("Ollamaサーバーから応答ボディがありません。");

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value, { stream: true });
                    chunk.trim().split('\n').forEach(line => {
                        if (line) {
                            try {
                                const json = JSON.parse(line);
                                if (json.response) {
                                    result += json.response;
                                    responseParagraph.innerHTML = `<strong>回答:</strong> ${result.replace(/\n/g, '<br>')}`;
                                }
                            } catch (e) {
                            }
                        }
                    });
                }
                
                responseParagraph.innerHTML = `<strong>回答:</strong> ${result.replace(/\n/g, '<br>')}`;
                userInputElement.value = '';

            } catch (error) {
                responseParagraph.innerHTML = `<strong>回答:</strong> エラーが発生しました: ${error.message}`;
                console.error("Model request error:", error);
            } finally {
                sendButton.disabled = false;
                sendButton.textContent = '送信';
                chatLog.scrollTop = chatLog.scrollHeight;
            }
        }
        
        // --- 初期化とイベントリスナー設定 ---
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('sendButton').addEventListener('click', sendToModel);
            
            document.getElementById('userInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendToModel();
                }
            });
        });
    </script>
</body>
</html>