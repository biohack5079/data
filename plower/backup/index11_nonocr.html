<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>RAGãƒ™ãƒ¼ã‚¹ NotebookLMé¢¨ãƒ­ãƒ¼ã‚«ãƒ«ã‚¢ãƒ—ãƒªã€Œplowerã€</title>
    <script src='https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js'></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            line-height: 1.6;
        }

        /* ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã¨ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´ */
        .rag-source-container {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        /* ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚¨ãƒªã‚¢ */
        #fileList {
            flex: 0 0 250px; /* å¹…ã‚’å›ºå®š */
            border: 1px solid #ccc;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            background: #f8f8f8;
        }

        #fileList h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #333;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }

        #fileList ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #fileList li {
            padding: 5px 0;
            cursor: pointer;
            color: #007BFF;
            text-decoration: underline;
            font-size: 0.9em;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #fileList li:hover {
            color: #0056b3;
        }

        /* ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹è¡¨ç¤ºã‚¨ãƒªã‚¢ */
        #fileContent {
            flex-grow: 1; /* æ®‹ã‚Šã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’å ã‚ã‚‹ */
            white-space: pre-wrap;
            background: #eef;
            padding: 10px;
            border: 1px solid #ccc;
            min-height: 50px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        /* è²¼ã‚Šä»˜ã‘ã‚¨ãƒªã‚¢ */
        #pasteArea {
            height: 200px;
        }
        
        /* å…¥åŠ›ç³» */
        textarea {
            width: 100%;
            height: 50px;
            margin-top: 5px;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ccc;
        }

        label {
            display: block;
            margin-top: 15px;
            font-weight: bold;
        }

        select {
            padding: 8px;
            border: 1px solid #ccc;
            margin-right: 10px;
        }

        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            margin-top: 10px;
            margin-right: 5px;
        }
        
        #saveOcrButton {
              background-color: #007BFF;
        }
        
        /* ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #resetDocsButton {
            background-color: #dc3545; /* èµ¤è‰² */
            padding: 8px 15px;
            margin-left: 10px;
            margin-top: 5px; 
        }


        button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }

        /* ãƒãƒ£ãƒƒãƒˆãƒ­ã‚° */
        #chatLog {
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        #chatLog p {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #chatLog strong {
            color: #333;
            font-weight: bold;
        }
        
        /* è²¼ã‚Šä»˜ã‘ãŸç”»åƒã‚¹ã‚¿ã‚¤ãƒ« */
        #fileContent img {
            max-width: 100%;
            height: auto;
            border: 2px solid #555;
            margin-top: 5px;
            display: block;
        }
        
        /* OCRã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º */
        .ocr-status {
            font-weight: bold;
            padding: 5px 0;
            border-bottom: 1px dashed #ccc;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <h1>RAGãƒ™ãƒ¼ã‚¹ NotebookLMé¢¨ã‚¢ãƒ—ãƒªã€Œplowerã€</h1>

    <label for="fileInput">RAGã‚½ãƒ¼ã‚¹æ–‡æ›¸ (Textãƒ•ã‚¡ã‚¤ãƒ«):</label>
    <input type="file" id="fileInput" accept=".txt" multiple>
    
    <button id="resetDocsButton">RAGã‚½ãƒ¼ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ (LocalStorageå…¨å‰Šé™¤)</button>

    <div class="rag-source-container">
        <div id="fileList">
            <h3>RAGã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ (æ°¸ç¶šåŒ–/ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰)</h3>
            <ul id="fileListUl">
                </ul>
        </div>
        
        <div id="fileContent">ã€ã“ã“ã«èª­ã¿è¾¼ã¾ã‚ŒãŸæ–‡æ›¸ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¾ãŸã¯é¸æŠå†…å®¹ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‘</div>
    </div>
    <hr>

    <label for="pasteArea">ä¸€æ™‚çš„ãªRAGã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦ãƒ†ã‚­ã‚¹ãƒˆã¾ãŸã¯ç”»åƒã‚’è²¼ã‚Šä»˜ã‘:</label>
    <textarea id="pasteArea" placeholder="ã“ã“ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚Ctrl+Vã§ç”»åƒã‚’è²¼ã‚Šä»˜ã‘ã‚‹ã¨OCRå‡¦ç†ãŒé–‹å§‹ã•ã‚Œã¾ã™ã€‚"></textarea>

    <button id="saveOcrButton">OCR/è²¼ä»˜ãƒ†ã‚­ã‚¹ãƒˆã‚’æ°¸ç¶šãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜</button>
    <hr>

    <label for="userInput">è³ªå•ã‚’å…¥åŠ›:</label>
    <textarea id="userInput" placeholder="è³ªå•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."></textarea>
    
<label for="modelSelect">ãƒ¢ãƒ‡ãƒ«é¸æŠ:</label>
<select id="modelSelect">
    <option value="gemma:7b">Gemma 7B (Ollama)</option>
    <option value="gpt-oss:20b" selected>GPT-OSS 20B (Ollama)</option>
    <option value="gemma:12b">Gemma 12B (Ollama)</option> <option value="gpt-oss:120b">GPT-OSS 120B (Ollama)</option>

    <option value="gemini-1.5-flash">Gemini 1.5 Flash (ã‚¯ãƒ©ã‚¦ãƒ‰)</option>
    <option value="gemini-1.5-pro">Gemini 1.5 Pro (ã‚¯ãƒ©ã‚¦ãƒ‰)</option>
</select>
    
    <button id="sendButton">é€ä¿¡</button>
    
    <div id="chatLog"></div>

    <script>
        // æ°¸ç¶šåŒ–ã•ã‚ŒãŸæ–‡æ›¸ã‚’æ ¼ç´ (LocalStorageã‹ã‚‰ãƒ­ãƒ¼ãƒ‰)
        let persistentDocuments = []; 
        // è²¼ã‚Šä»˜ã‘ç”»åƒã‹ã‚‰OCRå‡¦ç†ã§ç”Ÿæˆã•ã‚ŒãŸä¸€æ™‚æ–‡æ›¸ã‚’æ ¼ç´
        let ocrDocuments = []; 
        
        // Tesseract Workerã‚’åˆæœŸåŒ–ï¼ˆOCRå‡¦ç†ç”¨ï¼‰
        let worker;
        
        const PREVIEW_MAX_DOCS = 5; // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è¡¨ç¤ºã‚¨ãƒªã‚¢ã«è¡¨ç¤ºã™ã‚‹æœ€å¤§ãƒ•ã‚¡ã‚¤ãƒ«æ•°

        // ğŸ’¡ ã‚¯ãƒ©ã‚¦ãƒ‰ï¼ˆGemini APIï¼‰ãƒ¢ãƒ‡ãƒ«ã®ãƒªã‚¹ãƒˆã‚’å®šç¾© (ãƒ¢ãƒ‡ãƒ«åˆ¤åˆ¥ã«åˆ©ç”¨)
        const GEMINI_MODELS = [
            "gemini-1.5-flash",
            "gemini-1.5-pro",
        ];

        // --- LocalStorageã‹ã‚‰ã®æ–‡æ›¸ãƒ­ãƒ¼ãƒ‰ã¨ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã®è¡¨ç¤º ---
        function loadDocuments() {
            try {
                const storedDocs = localStorage.getItem('plowerRAGDocs');
                persistentDocuments = storedDocs ? JSON.parse(storedDocs) : [];
                updateFileListDisplay();
            } catch (e) {
                console.error("Failed to load documents from LocalStorage:", e);
                persistentDocuments = [];
            }
        }
        
        // --- LocalStorageã¸ã®æ–‡æ›¸ä¿å­˜ ---
        function saveDocuments() {
            try {
                localStorage.setItem('plowerRAGDocs', JSON.stringify(persistentDocuments));
            } catch (e) {
                console.error("Failed to save documents to LocalStorage:", e);
            }
        }
        
        // ğŸ’¡ LocalStorageã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹é–¢æ•°
        function resetDocuments() {
            if (confirm("æœ¬å½“ã«RAGã‚½ãƒ¼ã‚¹æ–‡æ›¸ã‚’å…¨ã¦å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nï¼ˆã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãŒLocalStorageã‹ã‚‰å…¨ã¦æ¶ˆå»ã•ã‚Œã¾ã™ã€‚ï¼‰")) {
                try {
                    // LocalStorageã‹ã‚‰ã‚­ãƒ¼ã‚’å‰Šé™¤
                    localStorage.removeItem('plowerRAGDocs');
                    
                    // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
                    persistentDocuments = [];
                    ocrDocuments = [];
                    document.getElementById('pasteArea').value = '';
                    document.querySelectorAll('#fileContent img, #fileContent .ocr-status').forEach(el => el.remove());

                    // UIã‚’æ›´æ–°
                    updateFileListDisplay(); 
                    
                    alert("RAGã‚½ãƒ¼ã‚¹æ–‡æ›¸ã‚’å…¨ã¦ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚");
                } catch (e) {
                    console.error("Failed to reset documents:", e);
                    alert("ãƒªã‚»ãƒƒãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
                }
            }
        }


        // --- ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§è¡¨ç¤ºã®æ›´æ–°ã¨ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š ---
        function updateFileListDisplay() {
            const fileListUl = document.getElementById('fileListUl');
            const fileContentDiv = document.getElementById('fileContent');
            fileListUl.innerHTML = '';
            
            // ãƒ•ã‚¡ã‚¤ãƒ«åã®ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆ
            persistentDocuments.forEach((doc, index) => {
                const li = document.createElement('li');
                li.textContent = doc.name;
                li.title = doc.name; // ãƒ›ãƒãƒ¼ã§ãƒ•ãƒ«ãƒãƒ¼ãƒ ã‚’è¡¨ç¤º
                li.dataset.docIndex = index;
                li.onclick = (e) => showDocumentContent(e.target.dataset.docIndex);
                fileListUl.appendChild(li);
            });
            
            // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è¡¨ç¤ºã‚¨ãƒªã‚¢ã®åˆæœŸè¡¨ç¤ºï¼ˆæœ€æ–°ã®æ•°ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰
            let initialContent = '<h3>RAGã‚½ãƒ¼ã‚¹æ–‡æ›¸ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ (æœ€æ–°5ä»¶)</h3>\n';
            const recentDocs = persistentDocuments.slice(-PREVIEW_MAX_DOCS).reverse();
            
            if (recentDocs.length > 0) {
                recentDocs.forEach(doc => {
                    const previewText = doc.content.slice(0, 300) + (doc.content.length > 300 ? '...' : '');
                    initialContent += `<p><strong>ã€${doc.name}ã€‘</strong></p><pre>${previewText}</pre>\n`;
                });
            } else {
                 initialContent += '<p>ç¾åœ¨RAGã®ã‚½ãƒ¼ã‚¹ã¨ãªã‚‹æ–‡æ›¸ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
            }
            fileContentDiv.innerHTML = initialContent;
            
            // OCRã§æ®‹ã£ã¦ã„ã‚‹ç”»åƒã‚„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒã‚ã‚Œã°å†æŒ¿å…¥
            const existingOcrContent = document.querySelectorAll('#fileContent img, #fileContent .ocr-status');
            existingOcrContent.forEach(el => fileContentDiv.prepend(el));
        }

        // --- ãƒ•ã‚¡ã‚¤ãƒ«åã‚¯ãƒªãƒƒã‚¯æ™‚ã®å†…å®¹è¡¨ç¤º ---
        function showDocumentContent(index) {
            const fileContentDiv = document.getElementById('fileContent');
            const doc = persistentDocuments[index];
            if (doc) {
                fileContentDiv.innerHTML = `<h3>é¸æŠä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«: ${doc.name}</h3><pre>${doc.content}</pre>`;
                
                // OCRã§æ®‹ã£ã¦ã„ã‚‹ç”»åƒã‚„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒã‚ã‚Œã°ã‚¯ãƒªã‚¢
                document.querySelectorAll('#fileContent img, #fileContent .ocr-status').forEach(el => el.remove());
            }
        }

        // --- Tesseract.js OCRå‡¦ç†é–¢æ•° ---
        async function runOcrOnImage(base64Image, statusElement) {
            if (!worker) {
                statusElement.textContent = 'OCRãƒ¯ãƒ¼ã‚«ãƒ¼ã‚’åˆæœŸåŒ–ä¸­... (åˆå›ã®ã¿æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™)';
                worker = await Tesseract.createWorker({
                    logger: m => {
                        if (m.status === 'recognizing text' && m.progress) {
                            statusElement.textContent = `OCRå‡¦ç†ä¸­: ${Math.round(m.progress * 100)}%`;
                        } else if (m.status) {
                            statusElement.textContent = `OCRã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${m.status}`;
                        }
                    },
                });
                await worker.loadLanguage('jpn+eng'); 
                await worker.initialize('jpn+eng');
                statusElement.textContent = 'OCRãƒ¯ãƒ¼ã‚«ãƒ¼ã®åˆæœŸåŒ–å®Œäº†ã€‚ãƒ†ã‚­ã‚¹ãƒˆèªè­˜ä¸­...';
            }

            const { data: { text } } = await worker.recognize(base64Image);
            
            return text;
        }


        // --- ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        document.getElementById('fileInput').addEventListener('change', function () {
            const files = this.files;
            
            // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ persistentDocuments ã«è¿½åŠ 
            const fileReads = Array.from(files).map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const docName = file.name;
                        const newDoc = { name: docName, content: e.target.result };
                        persistentDocuments.push(newDoc);
                        resolve();
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            });

            Promise.all(fileReads)
                .then(() => {
                    saveDocuments();
                    updateFileListDisplay();
                    alert(`æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ« ${files.length} ä»¶ã‚’RAGã‚½ãƒ¼ã‚¹ã«è¿½åŠ ã—ã¾ã—ãŸã€‚`);
                })
                .catch(error => {
                    alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
                    console.error("File reading error:", error);
                });
            
            this.value = ''; // é€£ç¶šã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®ãŸã‚ã«inputã‚’ã‚¯ãƒªã‚¢
        });
        
        // --- è²¼ã‚Šä»˜ã‘ç”»åƒå‡¦ç†ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (OCRé€£æºãƒ­ã‚¸ãƒƒã‚¯) ---
        document.getElementById('pasteArea').addEventListener('paste', async function (e) {
            const items = e.clipboardData.items;
            let imageFound = false;
            
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.type.indexOf('image') !== -1) {
                    e.preventDefault(); 
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    imageFound = true;
                    
                    // OCRçµæœã¯ä¸€æ—¦ã‚¯ãƒªã‚¢
                    ocrDocuments = [];
                    
                    // æ—¢å­˜ã®OCRé–¢é€£è¦ç´ ã‚’ã‚¯ãƒªã‚¢
                    document.querySelectorAll('#fileContent img, #fileContent .ocr-status').forEach(el => el.remove());

                    // å‡¦ç†ä¸­ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºè¦ç´ 
                    const processingMessage = document.createElement('p');
                    processingMessage.className = 'ocr-status';
                    processingMessage.textContent = 'ç”»åƒã‚’è²¼ã‚Šä»˜ã‘ã¾ã—ãŸã€‚OCRå‡¦ç†ã‚’é–‹å§‹ã—ã¦ã„ã¾ã™...';
                    processingMessage.style.color = 'orange';
                    document.getElementById('fileContent').prepend(processingMessage);

                    reader.onload = async function (event) {
                        const base64Image = event.target.result;
                        const imageName = `è²¼ã‚Šä»˜ã‘ç”»åƒ_${Date.now()}`;
                        
                        // ç”»åƒã‚’fileContentã‚¨ãƒªã‚¢ã«è¡¨ç¤º
                        const img = document.createElement('img');
                        img.src = base64Image;
                        img.alt = imageName;
                        document.getElementById('fileContent').prepend(img);
                        
                        try {
                            // 1. OCRå‡¦ç†ã‚’å®Ÿè¡Œ
                            const ocrText = await runOcrOnImage(base64Image, processingMessage);
                            
                            // 2. OCRçµæœã‚’ä¸€æ™‚æ–‡æ›¸ã¨ã—ã¦ä¿æŒ
                            const fullOcrContent = ocrText.trim(); 
                            ocrDocuments.push({
                                name: imageName,
                                content: fullOcrContent
                            });
                            
                            // 3. ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
                            processingMessage.textContent = `OCRå‡¦ç†å®Œäº†: ${imageName} ã®ãƒ†ã‚­ã‚¹ãƒˆãŒRAGå¯¾è±¡ã«è¿½åŠ ã•ã‚Œã¾ã—ãŸ (ä¸€æ™‚ä¿å­˜)ã€‚`;
                            processingMessage.style.color = 'green';
                            
                        } catch (error) {
                            processingMessage.textContent = `OCRå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`;
                            processingMessage.style.color = 'red';
                            console.error("OCR Error:", error);
                        } finally {
                            document.getElementById('pasteArea').value = '';
                        }
                    };
                    reader.readAsDataURL(blob);
                    break;
                }
            }
            
            // ç”»åƒè²¼ã‚Šä»˜ã‘ã§ã¯ãªã„å ´åˆã¯ãƒ†ã‚­ã‚¹ãƒˆè²¼ã‚Šä»˜ã‘ãªã®ã§å‡¦ç†ã‚’ã—ãªã„
        });
        
        // --- OCR/è²¼ä»˜ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã¨æ°¸ç¶šåŒ– ---
        document.getElementById('saveOcrButton').addEventListener('click', saveOcrTextAsFile);

        function saveOcrTextAsFile() {
            const allTextDocuments = [...ocrDocuments];
            const pasteAreaContent = document.getElementById('pasteArea').value.trim();
            
            if (pasteAreaContent) {
                 allTextDocuments.push({ name: 'è²¼ä»˜ãƒ†ã‚­ã‚¹ãƒˆ', content: pasteAreaContent });
            }

            if (allTextDocuments.length === 0) {
                alert("æ°¸ç¶šåŒ–ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆï¼ˆOCRçµæœã¾ãŸã¯è²¼ä»˜ã‚¨ãƒªã‚¢ã®å†…å®¹ï¼‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
                return;
            }

            // 1. LocalStorageã«æ°¸ç¶šåŒ– (ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ä»˜ã‘ã¦ persistentDocuments ã«è¿½åŠ )
            const now = new Date();
            const pad = (num) => num.toString().padStart(2, '0');
            const filename = `plower_memo_${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.txt`;
            
            let contentToSave = '';
            allTextDocuments.forEach(doc => {
                contentToSave += `--- ãƒ•ã‚¡ã‚¤ãƒ«å: ${doc.name} ---\n`;
                contentToSave += doc.content + '\n\n';
            });
            
            persistentDocuments.push({ name: filename, content: contentToSave });
            saveDocuments();
            updateFileListDisplay();
            
            // 2. ãƒ­ãƒ¼ã‚«ãƒ«PCã«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ (ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ©ã¸ã®ä¿å­˜)
            const blob = new Blob([contentToSave], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // 3. UIã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            alert(`OCR/è²¼ä»˜ãƒ†ã‚­ã‚¹ãƒˆã‚’ã€Œ${filename}ã€ã¨ã—ã¦ä¿å­˜ã—ã€RAGã‚½ãƒ¼ã‚¹ã¨ã—ã¦æ°¸ç¶šåŒ–ã—ã¾ã—ãŸã€‚`);
            
            document.getElementById('pasteArea').value = '';
            ocrDocuments = [];
            document.querySelectorAll('#fileContent img, #fileContent .ocr-status').forEach(el => el.remove());

        }


        // --- é–¢é€£æ–‡æ›¸æ¤œç´¢ãƒ­ã‚¸ãƒƒã‚¯ (ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒãƒ³ã‚°) ---
        function findRelevantDocs(query, docs, topK = 3) {
            if (!docs || docs.length === 0) return [];
            
            // ğŸ’¡ RAGæ¤œç´¢ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ”¹å–„: åŠ©è©ã‚„å¥èª­ç‚¹ã‚’é™¤å»ã—ãŸå˜èªãƒªã‚¹ãƒˆã§æ¤œç´¢
            const contentCleanedQuery = query.toLowerCase()
                .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()ï¼Ÿã€‚ã€ã¯ãŒã‚’ã«ã§ã¨]/g, " ") // æ—¥æœ¬èªã®åŠ©è©ãƒ»å¥èª­ç‚¹ã‚‚é™¤å»
                .split(/\s+/)
                .filter(t => t.length > 1); // 1æ–‡å­—ä»¥ä¸‹ã®å˜èªã¯ç„¡è¦–

            const searchTerms = Array.from(new Set([query.toLowerCase(), ...contentCleanedQuery])); // å…ƒã®ã‚¯ã‚¨ãƒªã¨å˜èªãƒªã‚¹ãƒˆã‚’çµ±åˆ

            const scores = docs.map(doc => {
                const content = (doc.content || '').toLowerCase();
                let score = 0;
                
                searchTerms.forEach(term => {
                    // å…¨ä½“ä¸€è‡´ã¨éƒ¨åˆ†ä¸€è‡´ã®ä¸¡æ–¹ã§ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
                    const count = (content.match(new RegExp(term, 'g')) || []).length; 
                    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®æ–‡å­—æ•°ã§é‡ã¿ä»˜ã‘ (é•·ã„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã»ã©é‡è¦)
                    score += count * term.length; 
                });
                return { ...doc, score };
            });
            
            // ã‚¹ã‚³ã‚¢ãŒ0ã‚ˆã‚Šå¤§ãã„æ–‡æ›¸ã‚’ã‚½ãƒ¼ãƒˆã—ã¦è¿”ã™
            return scores.filter(doc => doc.score > 0).sort((a, b) => b.score - a.score).slice(0, topK);
        }

        // --- ãƒ¢ãƒ‡ãƒ«é€ä¿¡ãƒ­ã‚¸ãƒƒã‚¯ (Ollama/Gemini åˆ‡ã‚Šæ›¿ãˆ) ---
        async function sendToModel() {
            const userInputElement = document.getElementById('userInput');
            const userInput = userInputElement.value.trim();
            const pasteAreaContent = document.getElementById('pasteArea').value.trim();
            const chatLog = document.getElementById('chatLog');
            const sendButton = document.getElementById('sendButton');
            const modelSelect = document.getElementById('modelSelect').value; 

            if (!userInput) {
                alert("è³ªå•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
                return;
            }
            
            sendButton.disabled = true;
            sendButton.textContent = 'é€ä¿¡ä¸­...';
            chatLog.innerHTML += `<p><strong>è³ªå•:</strong> ${userInput}</p>`;
            const responseParagraph = document.createElement('p');
            responseParagraph.innerHTML = '<strong>å›ç­”:</strong> (å¿œç­”å¾…æ©Ÿä¸­...)';
            chatLog.appendChild(responseParagraph);
            
            // å…¨ã¦ã®RAGã‚½ãƒ¼ã‚¹ã‚’çµ±åˆ
            let allDocuments = [...persistentDocuments, ...ocrDocuments];
            if (pasteAreaContent) {
                allDocuments.push({ name: 'è²¼ä»˜ã‘ãƒ†ã‚­ã‚¹ãƒˆ(ä¸€æ™‚)', content: pasteAreaContent });
            }

            // RAGã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ç”Ÿæˆ
            const relevantDocs = findRelevantDocs(userInput, allDocuments);
            const context = relevantDocs.map(doc => `ã€${doc.name}ã€‘\n${doc.content}`).join('\n\n').slice(0, 5000);
            
            // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®ç”Ÿæˆ
            const prompt = `ã‚ãªãŸã¯RAGã‚·ã‚¹ãƒ†ãƒ ã¨ã—ã¦æ©Ÿèƒ½ã—ã¾ã™ã€‚æä¾›ã•ã‚ŒãŸä»¥ä¸‹ã®æ–‡æ›¸ã«åŸºã¥ã„ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•ã«æ—¥æœ¬èªã§ç°¡æ½”ã«ç­”ãˆã¦ãã ã•ã„ã€‚
            æ–‡æ›¸ã«é–¢é€£æƒ…å ±ãŒãªã„å ´åˆã¯ã€ã€Œæä¾›ã•ã‚ŒãŸæ–‡æ›¸ã«é–¢é€£æƒ…å ±ãŒãªã„ãŸã‚å›ç­”ã§ãã¾ã›ã‚“ã€‚ã€ã¨ä¼ãˆã¦ãã ã•ã„ã€‚
            å‚ç…§ã—ãŸæ–‡æ›¸åï¼ˆã€æ–‡æ›¸åã€‘ï¼‰ã‚’å¼•ç”¨ã¨ã—ã¦å›ç­”ã®æœ«å°¾ã«è¨˜è¼‰ã—ã¦ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚

--- æ–‡æ›¸ ---
${context}
---

è³ªå•: ${userInput}`;

            let result = '';
            let endpoint = '';
            let bodyData = {};
            let isStreaming = false;
            
            // --- ğŸ’¡ ãƒ¢ãƒ‡ãƒ«ã®æŒ¯ã‚Šåˆ†ã‘ãƒ­ã‚¸ãƒƒã‚¯ ---
            const isGeminiCloudModel = GEMINI_MODELS.includes(modelSelect);
            
            if (isGeminiCloudModel) {
                // --- Gemini Cloud Model (FastAPIãƒ—ãƒ­ã‚­ã‚·çµŒç”±) ---
                endpoint = 'http://localhost:8001/api/gemini_proxy'; 
                bodyData = {
                    model: modelSelect, 
                    prompt: prompt,
                    temperature: 0.1
                };
                isStreaming = false; 

            } else {
                // --- Ollama Local Model ---
                endpoint = 'http://localhost:11434/api/generate';
                // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚µã‚¤ã‚ºè¨­å®š (Ollamaãƒ¢ãƒ‡ãƒ«ã®ã¿)
                const numCtx = (modelSelect.includes('20b') || modelSelect.includes('12b') || modelSelect.includes('120b')) ? 8192 : 4096;
                
                bodyData = {
                    model: modelSelect, 
                    prompt: prompt,
                    stream: true,
                    options: { 
                        temperature: 0.1, 
                        num_ctx: numCtx
                    }
                };
                isStreaming = true;
            }

            try {
                // --- APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å®Ÿè¡Œ ---
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(bodyData)
                });

                if (!response.ok) {
                    const errorDetail = await response.text();
                    const errorSource = isGeminiCloudModel ? 'FastAPIãƒ—ãƒ­ã‚­ã‚·/Gemini API' : 'Ollamaã‚µãƒ¼ãƒãƒ¼';
                    // ğŸ’¡ ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä¿®æ­£: modelSelectã¯ã™ã§ã«ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãªã—ã®å€¤ãªã®ã§ã€ãã®ã¾ã¾è¡¨ç¤º
                    throw new Error(`${errorSource} ã‚¨ãƒ©ãƒ¼: ${response.status} ${response.statusText}. ãƒ¢ãƒ‡ãƒ«: ${modelSelect} ã®ãƒ­ãƒ¼ãƒ‰ã¾ãŸã¯é€šä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚è©³ç´°: ${errorDetail.slice(0, 100)}...`);
                }

                // --- ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°/éã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã®å‡¦ç†åˆ†å² ---
                if (isStreaming) {
                    // Ollama (ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°) å‡¦ç†
                    if (!response.body) throw new Error("Ollamaã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰å¿œç­”ãƒœãƒ‡ã‚£ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        const chunk = decoder.decode(value, { stream: true });
                        chunk.trim().split('\n').forEach(line => {
                            if (line) {
                                try {
                                    const json = JSON.parse(line);
                                    if (json.response) {
                                        result += json.response;
                                        responseParagraph.innerHTML = `<strong>å›ç­”:</strong> ${result.replace(/\n/g, '<br>')}`;
                                    }
                                } catch (e) {
                                    // JSONè§£æã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                                }
                            }
                        });
                    }
                } else {
                    // Gemini (éã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°) å‡¦ç† (FastAPIãƒ—ãƒ­ã‚­ã‚·ã‹ã‚‰ã®å˜ä¸€JSONå¿œç­”)
                    const json = await response.json();
                    if (json.response) {
                        result = json.response;
                    } else if (json.detail) {
                        throw new Error(`Geminiãƒ—ãƒ­ã‚­ã‚·å‡¦ç†ã‚¨ãƒ©ãƒ¼: ${json.detail}`);
                    } else {
                        throw new Error("FastAPIãƒ—ãƒ­ã‚­ã‚·ã‹ã‚‰ã®äºˆæœŸã—ãªã„å¿œç­”å½¢å¼ã§ã™ã€‚");
                    }
                }
                
                // æœ€çµ‚çµæœã®è¡¨ç¤º
                responseParagraph.innerHTML = `<strong>å›ç­”:</strong> ${result.replace(/\n/g, '<br>')}`;
                userInputElement.value = '';

            } catch (error) {
                responseParagraph.innerHTML = `<strong>å›ç­”:</strong> ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`;
                console.error("Model request error:", error);
            } finally {
                sendButton.disabled = false;
                sendButton.textContent = 'é€ä¿¡';
                chatLog.scrollTop = chatLog.scrollHeight;
            }
        }
        
        // --- åˆæœŸåŒ–ã¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š ---
        document.addEventListener('DOMContentLoaded', () => {
            loadDocuments(); 
            document.getElementById('sendButton').addEventListener('click', sendToModel);
            // ğŸ’¡ ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            document.getElementById('resetDocsButton').addEventListener('click', resetDocuments);
            
            document.getElementById('userInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendToModel();
                }
            });
        });
    </script>
</body>
</html>