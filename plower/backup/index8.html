<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>RAGベース NotebookLM風ローカルアプリ「plower」</title>
    <script src='https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js'></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            line-height: 1.6;
        }

        /* ファイル一覧とコンテンツのレイアウト調整 */
        .rag-source-container {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        /* ファイル一覧エリア */
        #fileList {
            flex: 0 0 250px; /* 幅を固定 */
            border: 1px solid #ccc;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            background: #f8f8f8;
        }

        #fileList h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #333;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }

        #fileList ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #fileList li {
            padding: 5px 0;
            cursor: pointer;
            color: #007BFF;
            text-decoration: underline;
            font-size: 0.9em;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #fileList li:hover {
            color: #0056b3;
        }

        /* ファイル内容表示エリア */
        #fileContent {
            flex-grow: 1; /* 残りのスペースを占める */
            white-space: pre-wrap;
            background: #eef;
            padding: 10px;
            border: 1px solid #ccc;
            min-height: 50px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        /* 貼り付けエリア */
        #pasteArea {
            height: 50px;
        }
        
        /* 入力系 */
        textarea {
            width: 100%;
            height: 100px;
            margin-top: 5px;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ccc;
        }

        label {
            display: block;
            margin-top: 15px;
            font-weight: bold;
        }

        select {
            padding: 8px;
            border: 1px solid #ccc;
            margin-right: 10px;
        }

        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            margin-top: 10px;
            margin-right: 5px;
        }
        
        #saveOcrButton {
              background-color: #007BFF;
        }

        button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }

        /* チャットログ */
        #chatLog {
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        #chatLog p {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #chatLog strong {
            color: #333;
            font-weight: bold;
        }
        
        /* 貼り付けた画像スタイル */
        #fileContent img {
            max-width: 100%;
            height: auto;
            border: 2px solid #555;
            margin-top: 5px;
            display: block;
        }
        
        /* OCRステータス表示 */
        .ocr-status {
            font-weight: bold;
            padding: 5px 0;
            border-bottom: 1px dashed #ccc;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <h1>RAGベース NotebookLM風アプリ「plower」</h1>

    <label for="fileInput">RAGソース文書 (Textファイル):</label>
    <input type="file" id="fileInput" accept=".txt" multiple>
    
    <div class="rag-source-container">
        <div id="fileList">
            <h3>RAGソースファイル一覧 (永続化/アップロード)</h3>
            <ul id="fileListUl">
                </ul>
        </div>
        
        <div id="fileContent">【ここに読み込まれた文書のプレビューまたは選択内容が表示されます】</div>
    </div>
    <hr>

    <label for="pasteArea">一時的なRAGコンテキストとしてテキストまたは画像を貼り付け:</label>
    <textarea id="pasteArea" placeholder="ここにテキストを貼り付けてください。Ctrl+Vで画像を貼り付けるとOCR処理が開始されます。"></textarea>

    <button id="saveOcrButton">OCR/貼付テキストを永続ファイルとして保存</button>
    <hr>

    <label for="userInput">質問を入力:</label>
    <textarea id="userInput" placeholder="質問を入力してください..."></textarea>
    
<label for="modelSelect">モデル選択:</label>
<select id="modelSelect">
    <option value="gemma:7b">Gemma 7B (Ollama)</option>
    <option value="gpt-oss:20b" selected>GPT-OSS 20B (Ollama)</option>
    <option value="gemma3:12b">Gemma 12B (Ollama)</option>
    <option value="gpt-oss:120b">GPT-OSS 120B (Ollama)</option>

    <option value="gemini-1.5-flash">Gemini 1.5 Flash (クラウド)</option>
    <option value="gemini-1.5-pro">Gemini 1.5 Pro (クラウド)</option>
</select>
    
    <button id="sendButton">送信</button>
    
    <div id="chatLog"></div>

    <script>
        // 永続化された文書を格納 (LocalStorageからロード)
        let persistentDocuments = []; 
        // 貼り付け画像からOCR処理で生成された一時文書を格納
        let ocrDocuments = []; 
        
        // Tesseract Workerを初期化（OCR処理用）
        let worker;
        
        const PREVIEW_MAX_DOCS = 5; // コンテンツ表示エリアに表示する最大ファイル数

        // クラウド（Gemini API）モデルのリストを定義 (モデル判別に利用)
        const GEMINI_MODELS = [
            "gemini-1.5-flash",
            "gemini-1.5-pro",
        ];

        // --- LocalStorageからの文書ロードとファイル一覧の表示 ---
        function loadDocuments() {
            try {
                const storedDocs = localStorage.getItem('plowerRAGDocs');
                persistentDocuments = storedDocs ? JSON.parse(storedDocs) : [];
                updateFileListDisplay();
            } catch (e) {
                console.error("Failed to load documents from LocalStorage:", e);
                persistentDocuments = [];
            }
        }
        
        // --- LocalStorageへの文書保存 ---
        function saveDocuments() {
            try {
                localStorage.setItem('plowerRAGDocs', JSON.stringify(persistentDocuments));
            } catch (e) {
                console.error("Failed to save documents to LocalStorage:", e);
            }
        }

        // --- ファイル一覧表示の更新とクリックイベント設定 ---
        function updateFileListDisplay() {
            const fileListUl = document.getElementById('fileListUl');
            const fileContentDiv = document.getElementById('fileContent');
            fileListUl.innerHTML = '';
            
            // ファイル名のリストを生成
            persistentDocuments.forEach((doc, index) => {
                const li = document.createElement('li');
                li.textContent = doc.name;
                li.title = doc.name; // ホバーでフルネームを表示
                li.dataset.docIndex = index;
                li.onclick = (e) => showDocumentContent(e.target.dataset.docIndex);
                fileListUl.appendChild(li);
            });
            
            // コンテンツ表示エリアの初期表示（最新の数ファイル）
            let initialContent = '<h3>RAGソース文書プレビュー (最新5件)</h3>\n';
            const recentDocs = persistentDocuments.slice(-PREVIEW_MAX_DOCS).reverse();
            
            if (recentDocs.length > 0) {
                recentDocs.forEach(doc => {
                    const previewText = doc.content.slice(0, 300) + (doc.content.length > 300 ? '...' : '');
                    initialContent += `<p><strong>【${doc.name}】</strong></p><pre>${previewText}</pre>\n`;
                });
            } else {
                 initialContent += '<p>現在RAGのソースとなる文書はありません。</p>';
            }
            fileContentDiv.innerHTML = initialContent;
            
            // OCRで残っている画像やステータスがあれば再挿入
            const existingOcrContent = document.querySelectorAll('#fileContent img, #fileContent .ocr-status');
            existingOcrContent.forEach(el => fileContentDiv.prepend(el));
        }

        // --- ファイル名クリック時の内容表示 ---
        function showDocumentContent(index) {
            const fileContentDiv = document.getElementById('fileContent');
            const doc = persistentDocuments[index];
            if (doc) {
                fileContentDiv.innerHTML = `<h3>選択中のファイル: ${doc.name}</h3><pre>${doc.content}</pre>`;
                
                // OCRで残っている画像やステータスがあればクリア
                document.querySelectorAll('#fileContent img, #fileContent .ocr-status').forEach(el => el.remove());
            }
        }

        // --- Tesseract.js OCR処理関数 ---
        async function runOcrOnImage(base64Image, statusElement) {
            if (!worker) {
                statusElement.textContent = 'OCRワーカーを初期化中... (初回のみ時間がかかります)';
                worker = await Tesseract.createWorker({
                    logger: m => {
                        if (m.status === 'recognizing text' && m.progress) {
                            statusElement.textContent = `OCR処理中: ${Math.round(m.progress * 100)}%`;
                        } else if (m.status) {
                            statusElement.textContent = `OCRステータス: ${m.status}`;
                        }
                    },
                });
                // 言語設定は tesseract.js のダウンロード状況によるが、今回は汎用的な jpn+eng を使用
                await worker.loadLanguage('jpn+eng'); 
                await worker.initialize('jpn+eng');
                statusElement.textContent = 'OCRワーカーの初期化完了。テキスト認識中...';
            }

            const { data: { text } } = await worker.recognize(base64Image);
            
            return text;
        }


        // --- ファイル入力のイベントリスナー (既存ファイルおよび保存ファイルの再読み込み) ---
        document.getElementById('fileInput').addEventListener('change', function () {
            const files = this.files;
            
            // アップロードファイルを persistentDocuments に追加
            const fileReads = Array.from(files).map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        // ファイル名が重複しないようにチェック（今回は簡易的にタイムスタンプを付加）
                        const docName = file.name;
                        const newDoc = { name: docName, content: e.target.result };
                        persistentDocuments.push(newDoc);
                        resolve();
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            });

            Promise.all(fileReads)
                .then(() => {
                    saveDocuments();
                    updateFileListDisplay();
                    alert(`新しいファイル ${files.length} 件をRAGソースに追加しました。`);
                })
                .catch(error => {
                    alert('ファイルの読み込み中にエラーが発生しました。');
                    console.error("File reading error:", error);
                });
            
            this.value = ''; // 連続アップロードのためにinputをクリア
        });
        
        // --- 貼り付け画像処理のイベントリスナー (OCR連携ロジック) ---
        document.getElementById('pasteArea').addEventListener('paste', async function (e) {
            const items = e.clipboardData.items;
            let imageFound = false;
            
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.type.indexOf('image') !== -1) {
                    e.preventDefault(); 
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    imageFound = true;
                    
                    // OCR結果は一旦クリア
                    ocrDocuments = [];
                    
                    // 既存のOCR関連要素をクリア
                    document.querySelectorAll('#fileContent img, #fileContent .ocr-status').forEach(el => el.remove());

                    // 処理中メッセージ表示要素
                    const processingMessage = document.createElement('p');
                    processingMessage.className = 'ocr-status';
                    processingMessage.textContent = '画像を貼り付けました。OCR処理を開始しています...';
                    processingMessage.style.color = 'orange';
                    document.getElementById('fileContent').prepend(processingMessage);

                    reader.onload = async function (event) {
                        const base64Image = event.target.result;
                        const imageName = `貼り付け画像_${Date.now()}`;
                        
                        // 画像をfileContentエリアに表示
                        const img = document.createElement('img');
                        img.src = base64Image;
                        img.alt = imageName;
                        document.getElementById('fileContent').prepend(img);
                        
                        try {
                            // 1. OCR処理を実行
                            const ocrText = await runOcrOnImage(base64Image, processingMessage);
                            
                            // 2. OCR結果を一時文書として保持
                            const fullOcrContent = ocrText.trim(); 
                            ocrDocuments.push({
                                name: imageName,
                                content: fullOcrContent
                            });
                            
                            // 3. ステータス更新
                            processingMessage.textContent = `OCR処理完了: ${imageName} のテキストがRAG対象に追加されました (一時保存)。`;
                            processingMessage.style.color = 'green';
                            
                        } catch (error) {
                            processingMessage.textContent = `OCR処理中にエラーが発生しました: ${error.message}`;
                            processingMessage.style.color = 'red';
                            console.error("OCR Error:", error);
                        } finally {
                            document.getElementById('pasteArea').value = '';
                        }
                    };
                    reader.readAsDataURL(blob);
                    break;
                }
            }
            
            // 画像貼り付けではない場合はテキスト貼り付けなので処理をしない
        });
        
        // --- 独自追加機能: OCR/貼付テキストのファイル保存と永続化 ---
        document.getElementById('saveOcrButton').addEventListener('click', saveOcrTextAsFile);

        function saveOcrTextAsFile() {
            const allTextDocuments = [...ocrDocuments];
            const pasteAreaContent = document.getElementById('pasteArea').value.trim();
            
            if (pasteAreaContent) {
                 allTextDocuments.push({ name: '貼付テキスト', content: pasteAreaContent });
            }

            if (allTextDocuments.length === 0) {
                alert("永続化するテキスト（OCR結果または貼付エリアの内容）がありません。");
                return;
            }

            // 1. LocalStorageに永続化 (ファイル名を付けて persistentDocuments に追加)
            const now = new Date();
            // ファイル名生成 (例: plower_memo_20251107_85516.txt)
            const pad = (num) => num.toString().padStart(2, '0');
            const filename = `plower_memo_${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}.txt`;
            
            let contentToSave = '';
            allTextDocuments.forEach(doc => {
                contentToSave += `--- ファイル名: ${doc.name} ---\n`;
                contentToSave += doc.content + '\n\n';
            });
            
            persistentDocuments.push({ name: filename, content: contentToSave });
            saveDocuments();
            updateFileListDisplay();
            
            // 2. ローカルPCにダウンロード (エクスプローラへの保存)
            const blob = new Blob([contentToSave], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // 3. UIのクリーンアップ
            alert(`OCR/貼付テキストを「${filename}」として保存し、RAGソースとして永続化しました。`);
            
            document.getElementById('pasteArea').value = '';
            ocrDocuments = [];
            document.querySelectorAll('#fileContent img, #fileContent .ocr-status').forEach(el => el.remove());

        }


        // --- 関連文書検索ロジック (キーワードマッチング) ---
        function findRelevantDocs(query, docs, topK = 3) {
            if (!docs || docs.length === 0) return [];
            
            const scores = docs.map(doc => {
                const content = (doc.content || '').toLowerCase();
                const terms = query.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").split(/\s+/).filter(t => t.length > 0);
                let score = 0;
                
                terms.forEach(term => {
                    // キーワードの出現回数でスコアリング
                    const count = (content.match(new RegExp(term, 'g')) || []).length; 
                    score += count;
                });
                return { ...doc, score };
            });
            
            // スコアの高い順にソートし、Top-Kを返す
            return scores.filter(doc => doc.score > 0).sort((a, b) => b.score - a.score).slice(0, topK);
        }

        // --- モデル送信ロジック (Ollama/Gemini 切り替え) ---
        async function sendToModel() {
            const userInputElement = document.getElementById('userInput');
            const userInput = userInputElement.value.trim();
            const pasteAreaContent = document.getElementById('pasteArea').value.trim();
            const chatLog = document.getElementById('chatLog');
            const sendButton = document.getElementById('sendButton');
            const modelSelect = document.getElementById('modelSelect').value; // 例: "gpt-oss:20b" または "gemini-1.5-flash"

            if (!userInput) {
                alert("質問を入力してください。");
                return;
            }
            
            sendButton.disabled = true;
            sendButton.textContent = '送信中...';
            chatLog.innerHTML += `<p><strong>質問:</strong> ${userInput}</p>`;
            const responseParagraph = document.createElement('p');
            responseParagraph.innerHTML = '<strong>回答:</strong> (応答待機中...)';
            chatLog.appendChild(responseParagraph);
            
            // 永続化された文書 + OCR結果 + 貼り付けテキストの全てをRAG対象とする
            let allDocuments = [...persistentDocuments, ...ocrDocuments];
            if (pasteAreaContent) {
                allDocuments.push({ name: '貼付けテキスト(一時)', content: pasteAreaContent });
            }

            // RAGコンテキストの生成
            const relevantDocs = findRelevantDocs(userInput, allDocuments);
            // 関連文書をプロンプトに含める (最大5000文字)
            const context = relevantDocs.map(doc => `【${doc.name}】\n${doc.content}`).join('\n\n').slice(0, 5000);
            
            // プロンプトの生成
            const prompt = `あなたはRAGシステムとして機能します。提供された以下の文書に基づいて、ユーザーの質問に日本語で簡潔に答えてください。
            文書に関連情報がない場合は、「提供された文書に関連情報がないため回答できません。」と伝えてください。
            参照した文書名（【文書名】）を引用として回答の末尾に記載しても構いません。

--- 文書 ---
${context}
---

質問: ${userInput}`;

            let result = '';
            let endpoint = '';
            let bodyData = {};
            let isStreaming = false;
            
            // --- モデルの振り分けロジック ---
            const isGeminiCloudModel = GEMINI_MODELS.includes(modelSelect);
            
            if (isGeminiCloudModel) {
                // --- Gemini Cloud Model (FastAPIプロキシ経由) ---
                endpoint = 'http://localhost:8000/api/gemini_proxy'; 
                bodyData = {
                    model: modelSelect, // 例: "gemini-1.5-flash"
                    prompt: prompt,
                    temperature: 0.1
                };
                isStreaming = false; // FastAPIプロキシ側でストリーミングをOFFにしている前提

            } else {
                // --- Ollama Local Model ---
                endpoint = 'http://localhost:11434/api/generate';
                // コンテキストサイズの設定: 20B/12B/120Bは8192、それ以外は4096 (Ollamaモデルのみに適用)
                const numCtx = (modelSelect.includes('20b') || modelSelect.includes('12b') || modelSelect.includes('120b')) ? 8192 : 4096;
                
                bodyData = {
                    model: modelSelect, // 例: "gpt-oss:20b"
                    prompt: prompt,
                    stream: true,
                    options: { 
                        temperature: 0.1, 
                        num_ctx: numCtx
                    }
                };
                isStreaming = true;
            }

            try {
                // --- APIリクエストの実行 ---
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(bodyData)
                });

                if (!response.ok) {
                    const errorDetail = await response.text();
                    // エラーメッセージをより分かりやすく
                    const errorSource = isGeminiCloudModel ? 'FastAPIプロキシ/Gemini API' : 'Ollamaサーバー';
                    throw new Error(`${errorSource} エラー: ${response.status} ${response.statusText}. モデル: ${modelSelect} がロードできませんでした。詳細: ${errorDetail.slice(0, 100)}...`);
                }

                // --- ストリーミング/非ストリーミングの処理分岐 ---
                if (isStreaming) {
                    // Ollama (ストリーミング) 処理
                    if (!response.body) throw new Error("Ollamaサーバーから応答ボディがありません。");

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        const chunk = decoder.decode(value, { stream: true });
                        chunk.trim().split('\n').forEach(line => {
                            if (line) {
                                try {
                                    const json = JSON.parse(line);
                                    if (json.response) {
                                        result += json.response;
                                        responseParagraph.innerHTML = `<strong>回答:</strong> ${result.replace(/\n/g, '<br>')}`;
                                    }
                                } catch (e) {
                                    // JSON解析エラーは無視（次のチャンクで繋がる可能性があるため）
                                }
                            }
                        });
                    }
                } else {
                    // Gemini (非ストリーミング) 処理 (FastAPIプロキシからの単一JSON応答)
                    const json = await response.json();
                    if (json.response) {
                        result = json.response;
                    } else if (json.detail) {
                        // FastAPIプロキシからのエラーメッセージをキャッチ
                        throw new Error(`Geminiプロキシ処理エラー: ${json.detail}`);
                    } else {
                        throw new Error("FastAPIプロキシからの予期しない応答形式です。");
                    }
                }
                
                // 最終結果の表示
                responseParagraph.innerHTML = `<strong>回答:</strong> ${result.replace(/\n/g, '<br>')}`;
                userInputElement.value = '';

            } catch (error) {
                responseParagraph.innerHTML = `<strong>回答:</strong> エラーが発生しました: ${error.message}`;
                console.error("Model request error:", error);
            } finally {
                sendButton.disabled = false;
                sendButton.textContent = '送信';
                chatLog.scrollTop = chatLog.scrollHeight;
            }
        }
        
        // --- 初期化とイベントリスナー設定 ---
        document.addEventListener('DOMContentLoaded', () => {
            loadDocuments(); // 起動時に永続化された文書をロード
            document.getElementById('sendButton').addEventListener('click', sendToModel);
            
            // saveOcrButtonのイベントリスナーは上部に移動済み
            
            document.getElementById('userInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendToModel();
                }
            });
        });
    </script>
</body>
</html>