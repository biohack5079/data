<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>RAGベース NotebookLM風ローカルアプリ「plower」</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    textarea { width: 100%; height: 100px; margin-top: 10px; }
    button { margin-top: 10px; }
    #chatLog p { background: #f0f0f0; padding: 5px; border-radius: 5px; }
    #chatLog strong { color: #333; }
    #fileContent { white-space: pre-wrap; background: #eef; padding: 10px; margin-top: 10px; border: 1px solid #ccc; }
  </style>
</head>
<body>
  <h1>RAGベース NotebookLM風アプリ</h1>

  <input type="file" id="fileInput" accept=".txt" multiple>
  <div id="fileContent">【ここに読み込まれた文書の内容が表示されます】</div>

  <textarea id="userInput" placeholder="質問を入力してください..."></textarea>
  <button id="sendButton">送信</button> <div id="chatLog"></div>

  <script>
    let documents = [];

    // --- ファイル入力のイベントリスナー ---
    document.getElementById('fileInput').addEventListener('change', function () {
      const files = this.files;
      documents = []; // ドキュメントをリセット
      let displayText = '';
      const fileContentDiv = document.getElementById('fileContent');
      fileContentDiv.textContent = 'ファイルを読み込み中です...';

      // Promise.allで全てのファイル読み込み完了を待つ
      const fileReads = Array.from(files).map(file => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = function (e) {
            documents.push({ name: file.name, content: e.target.result });
            displayText += `【${file.name}】\n` + e.target.result.slice(0, 300) + '\n\n';
            resolve();
          };
          reader.onerror = reject;
          reader.readAsText(file);
        });
      });

      Promise.all(fileReads)
        .then(() => {
          fileContentDiv.textContent = displayText || 'ファイルが選択されていません。';
        })
        .catch(error => {
          fileContentDiv.textContent = 'ファイルの読み込み中にエラーが発生しました。';
          console.error("File reading error:", error);
        });
    });

    // --- 関連文書検索ロジック ---
    function findRelevantDocs(query, docs, topK = 3) {
      if (!docs || docs.length === 0) return [];
      const scores = docs.map(doc => {
        // nullチェックと小文字化
        const content = (doc.content || '').toLowerCase();
        const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 0);
        let score = 0;
        terms.forEach(term => {
          // 正規表現のエスケープ処理を追加 (より厳密にするなら必要だが、今回は簡略化)
          const count = (content.match(new RegExp(term, 'g')) || []).length;
          score += count;
        });
        return { ...doc, score };
      });
      return scores.sort((a, b) => b.score - a.score).slice(0, topK);
    }

    // --- モデル送信ロジック ---
    async function sendToModel() {
      const userInputElement = document.getElementById('userInput');
      const userInput = userInputElement.value.trim();
      const chatLog = document.getElementById('chatLog');
      const sendButton = document.getElementById('sendButton');

      if (!userInput) {
        alert("質問を入力してください。");
        return;
      }
      
      // 処理中のUIフィードバック
      sendButton.disabled = true;
      sendButton.textContent = '送信中...';
      chatLog.innerHTML += `<p><strong>質問:</strong> ${userInput}</p>`;
      const responseParagraph = document.createElement('p');
      responseParagraph.innerHTML = '<strong>回答:</strong> ';
      chatLog.appendChild(responseParagraph);

      // RAGコンテキストの生成
      const relevantDocs = findRelevantDocs(userInput, documents);
      const context = relevantDocs.map(doc => `【${doc.name}】\n${doc.content}`).join('\n\n').slice(0, 3000);
      
      // プロンプトの生成
      const prompt = `あなたはRAGシステムとして機能します。提供された以下の文書に基づいて、ユーザーの質問に日本語で簡潔に答えてください。文書に関連情報がない場合は、その旨を伝えてください。

--- 文書 ---
${context}
---

質問: ${userInput}`;

      let result = '';
      try {
        const response = await fetch('http://localhost:11434/api/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: 'gemma:7b',
            prompt: prompt,
            stream: true,
            // 追加設定: モデルの応答をより制御するため
            options: {
                temperature: 0.1,
                num_ctx: 4096 // コンテキストウィンドウサイズを増やす
            }
          })
        });

        if (!response.ok) throw new Error(`Ollamaサーバーエラー: ${response.status} ${response.statusText}`);
        if (!response.body) throw new Error("Ollamaサーバーから応答ボディがありません。");

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          const chunk = decoder.decode(value, { stream: true });
          
          // ストリーム応答処理 (複数行のJSONチャンクに対応)
          chunk.trim().split('\n').forEach(line => {
             if (line) {
                 try {
                     const json = JSON.parse(line);
                     if (json.response) {
                         result += json.response;
                         responseParagraph.innerHTML = `<strong>回答:</strong> ${result.replace(/\n/g, '<br>')}`;
                     }
                     if (json.done) {
                        // 応答終了
                     }
                 } catch (e) {
                     // console.warn("JSON parse error on line:", line, e);
                     // JSONパースエラーはストリームの途中で発生しやすいため、
                     // 応答が継続することを期待して無視または最小限のログに留める
                 }
             }
          });
        }
        
        // 最終的な回答を表示
        responseParagraph.innerHTML = `<strong>回答:</strong> ${result.replace(/\n/g, '<br>')}`;
        userInputElement.value = ''; // 入力欄をクリア

      } catch (error) {
        responseParagraph.innerHTML = `<strong>回答:</strong> エラーが発生しました: ${error.message}`;
        console.error("Model request error:", error);
      } finally {
        sendButton.disabled = false;
        sendButton.textContent = '送信';
        chatLog.scrollTop = chatLog.scrollHeight; // スクロールを最新に
      }
    }
    
    // --- DOMContentLoadedでイベントリスナーを登録 (重要) ---
    // これにより、HTML要素がすべてロードされた後に、JavaScriptが実行され、
    // sendToModel関数が定義された後にボタンにイベントが設定されます。
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('sendButton').addEventListener('click', sendToModel);
        
        // Enterキーでも送信できるようにする (Optional)
        document.getElementById('userInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendToModel();
            }
        });
    });
  </script>
</body>
</html>