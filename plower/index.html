<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>RAGベース NotebookLM風ローカルアプリ「plower」</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            line-height: 1.6;
        }

        /* ファイル内容表示エリア */
        #fileContent {
            white-space: pre-wrap;
            background: #eef;
            padding: 10px;
            margin-top: 10px;
            border: 1px solid #ccc;
            min-height: 50px; /* 見やすさのため */
            max-height: 200px; /* 高くなりすぎないように */
            overflow-y: auto;
        }

        /* 入力系 */
        textarea {
            width: 100%;
            height: 100px;
            margin-top: 5px;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ccc;
        }

        #userInput {
            margin-bottom: 5px;
        }

        label {
            display: block;
            margin-top: 15px;
            font-weight: bold;
        }

        select {
            padding: 8px;
            border: 1px solid #ccc;
            margin-right: 10px;
        }

        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            margin-top: 10px;
        }

        button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }

        /* チャットログ */
        #chatLog {
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        #chatLog p {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #chatLog strong {
            color: #333;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>RAGベース NotebookLM風アプリ「plower」</h1>

    <label for="fileInput">RAGソース文書 (Textファイル):</label>
    <input type="file" id="fileInput" accept=".txt" multiple>
    <div id="fileContent">【ここに読み込まれた文書の内容が表示されます（最初の300字）】</div>

    <label for="pasteArea">一時的なRAGコンテキストとしてテキストを貼り付け:</label>
    <textarea id="pasteArea" placeholder="ここにテキストを貼り付けてください。質問時にRAGの対象となります。"></textarea>

    <label for="userInput">質問を入力:</label>
    <textarea id="userInput" placeholder="質問を入力してください..."></textarea>
    
    <label for="modelSelect">モデル選択:</label>
    <select id="modelSelect">
        <option value="gemma:7b">Gemma 7B (推奨)</option>
        <option value="llama3:8b">Llama 3 8B</option>
        <option value="gemma:2b">Gemma 2B (軽量)</option>
        <option value="gpt-oss:20b">GPT-OSS 20B (未検証)</option>
        <option value="gpt-oss:120b">GPT-OSS 120B (要超高性能GPU)</option>
    </select>
    
    <button id="sendButton">送信</button>
    
    <div id="chatLog"></div>

    <script>
        // ファイル入力で読み込まれた文書を格納する配列
        let fileDocuments = [];

        // --- ファイル入力のイベントリスナー ---
        document.getElementById('fileInput').addEventListener('change', function () {
            const files = this.files;
            fileDocuments = []; // ファイル文書をリセット
            let displayText = '';
            const fileContentDiv = document.getElementById('fileContent');
            fileContentDiv.textContent = 'ファイルを読み込み中です...';

            const fileReads = Array.from(files).map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        fileDocuments.push({ name: file.name, content: e.target.result });
                        displayText += `【${file.name}】\n` + e.target.result.slice(0, 300) + '...\n\n';
                        resolve();
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            });

            Promise.all(fileReads)
                .then(() => {
                    fileContentDiv.textContent = displayText || 'ファイルが選択されていません。';
                })
                .catch(error => {
                    fileContentDiv.textContent = 'ファイルの読み込み中にエラーが発生しました。';
                    console.error("File reading error:", error);
                });
        });

        // --- 関連文書検索ロジック (キーワードマッチング) ---
        function findRelevantDocs(query, docs, topK = 3) {
            if (!docs || docs.length === 0) return [];
            
            const scores = docs.map(doc => {
                const content = (doc.content || '').toLowerCase();
                // 句読点や記号を除去し、スペースで区切って検索語を取得
                const terms = query.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").split(/\s+/).filter(t => t.length > 0);
                let score = 0;
                
                terms.forEach(term => {
                    // 単純な出現回数でスコアリング
                    const count = (content.match(new RegExp(term, 'g')) || []).length;
                    score += count;
                });
                return { ...doc, score };
            });
            
            // スコアの高い順にソートし、上位K件を返す
            return scores.sort((a, b) => b.score - a.score).slice(0, topK);
        }

        // --- モデル送信ロジック ---
        async function sendToModel() {
            const userInputElement = document.getElementById('userInput');
            const userInput = userInputElement.value.trim();
            const pasteAreaContent = document.getElementById('pasteArea').value.trim();
            const chatLog = document.getElementById('chatLog');
            const sendButton = document.getElementById('sendButton');
            const modelSelect = document.getElementById('modelSelect').value;

            if (!userInput) {
                alert("質問を入力してください。");
                return;
            }
            
            // 処理中のUIフィードバック
            sendButton.disabled = true;
            sendButton.textContent = '送信中...';
            chatLog.innerHTML += `<p><strong>質問:</strong> ${userInput}</p>`;
            const responseParagraph = document.createElement('p');
            responseParagraph.innerHTML = '<strong>回答:</strong> ';
            chatLog.appendChild(responseParagraph);

            // RAGの対象となる全ドキュメントリストを作成
            let allDocuments = [...fileDocuments];
            if (pasteAreaContent) {
                // 貼り付けエリアの内容を一時的なドキュメントとして追加
                allDocuments.push({ name: '貼付けテキスト', content: pasteAreaContent });
            }

            // RAGコンテキストの生成
            const relevantDocs = findRelevantDocs(userInput, allDocuments);
            // 上位の関連文書を結合し、最大5000文字に制限
            const context = relevantDocs.map(doc => `【${doc.name}】\n${doc.content}`).join('\n\n').slice(0, 5000);
            
            // プロンプトの生成
            const prompt = `あなたはRAGシステムとして機能します。提供された以下の文書に基づいて、ユーザーの質問に日本語で簡潔に答えてください。
            文書に関連情報がない場合は、「提供された文書に関連情報がないため回答できません。」と伝えてください。
            参照した文書名（【文書名】）を引用として回答の末尾に記載しても構いません。

--- 文書 ---
${context}
---

質問: ${userInput}`;

            // num_ctx はモデルのコンテキストウィンドウサイズに合わせて調整
            const numCtx = 4096; // 多くのモデルの標準的なコンテキストサイズ

            let result = '';
            try {
                const response = await fetch('http://localhost:11434/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: modelSelect, // ユーザーが選択したモデルを使用
                        prompt: prompt,
                        stream: true,
                        options: {
                            temperature: 0.1, // 創造性を抑え、事実に忠実な回答を促す
                            num_ctx: numCtx
                        }
                    })
                });

                if (!response.ok) throw new Error(`Ollamaサーバーエラー: ${response.status} ${response.statusText}. モデル名: ${modelSelect} がローカルにインストールされているか確認してください。`);
                if (!response.body) throw new Error("Ollamaサーバーから応答ボディがありません。");

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value, { stream: true });
                    // ストリーム応答処理
                    chunk.trim().split('\n').forEach(line => {
                        if (line) {
                            try {
                                const json = JSON.parse(line);
                                if (json.response) {
                                    result += json.response;
                                    // リアルタイム表示
                                    responseParagraph.innerHTML = `<strong>回答:</strong> ${result.replace(/\n/g, '<br>')}`;
                                }
                            } catch (e) {
                                // JSONパースエラーは無視
                            }
                        }
                    });
                }
                
                // 最終表示
                responseParagraph.innerHTML = `<strong>回答:</strong> ${result.replace(/\n/g, '<br>')}`;
                userInputElement.value = ''; // 入力欄をクリア

            } catch (error) {
                responseParagraph.innerHTML = `<strong>回答:</strong> エラーが発生しました: ${error.message}`;
                console.error("Model request error:", error);
            } finally {
                sendButton.disabled = false;
                sendButton.textContent = '送信';
                chatLog.scrollTop = chatLog.scrollHeight; // スクロールを最新に
            }
        }
        
        // --- 初期化とイベントリスナー設定 ---
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('sendButton').addEventListener('click', sendToModel);
            
            // Enterキーでの送信
            document.getElementById('userInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendToModel();
                }
            });
        });
    </script>
</body>
</html>